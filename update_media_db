#!/usr/bin/perl

use strict;
use warnings;
use DBI;
use JSON;
use Image::ExifTool ':Public';
use File::Find;
use File::Basename;
use Cwd;
use Data::Printer;
use Data::Dumper;
use Digest::MD5;
use Getopt::Long;

my $dbh = 0; # global database handle
my $verbose = 0;

sub connect_database($) {
  my ($database) = @_;
  my $driver = "SQLite";
  my $dsn = "DBI:$driver:dbname=$database";
  my $userid = "";
  my $password = "";
  my $dbh = DBI->connect($dsn, $userid, $password, { RaiseError => 1 })
    or die $DBI::errstr;
  return $dbh;
}

# absolute path of script
# that's where we'll look for the database
sub my_dir() {
  return File::Basename::dirname(Cwd::abs_path($0));
}

sub digest_from_file($) {
  my $file = $_[0];
  my $md5 = Digest::MD5->new;
  open(my $F, $file) or die $!;
  return Digest::MD5->new->addfile($F)->hexdigest;
}

sub hash_to_json($) {
  my %info = %{$_[0]};
  my %ihash;
  my $json = JSON->new();

  $json->pretty(1);

  foreach (sort keys %info) {
    my $val = $info{$_};
    my ($year, $month, $day, $rest);

    # change DateTime values into a format SQLite can understand
    if ($_ =~ "Date") {
      if (($year, $month, $day, $rest) = $val =~ /^(\d{4}):(\d{2}):(\d{2}) (.*)$/) {
        $val = "$year-$month-$day $rest";
      }
    }
    if (ref $val eq 'ARRAY') {
      $val = join(', ', @$val);
    } elsif (ref $val eq 'SCALAR') {
      $val = '(binary)';
    }
    $ihash{$_} = $val;
  }
  return $json->encode(\%ihash);
}

sub insert_into_db($$$$$$$$$$$$$$$) {
  my ($dbh, $path, $filename, $ext, $size, $mtime, $digest, $exif, $width, $height, $duration, $lat, $lon, $camera, $orig_time) = @_;
  my $sql = qq[INSERT INTO media(path, filename, ext, size, mtime, digest, exif, width, height, duration, lat, lon, camera, datetime_original)
                      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)];
  my $sth = $dbh->prepare($sql);
  $sth->execute($path, $filename, $ext, $size, $mtime, $digest, $exif, $width, $height, $duration, $lat, $lon, $camera, $orig_time)
    or die "$DBI::errstr: $path, $digest";
}

sub fetch_file_info($$) {
  my ($dbh, $path) = @_;
  my $sql = qq[SELECT path, filename, ext, size, mtime, digest FROM media WHERE path = ?];
  my $stmt = $dbh->prepare($sql);
  $stmt->execute($path) or die "$DBI::errstr: $path";
  return $stmt->fetchrow_hashref('NAME_lc');
}

sub reset_state($$) {
  my ($dbh, $path) = @_;
  my $sql = qq[UPDATE media SET state = 0 WHERE path = ?];
  my $stmt = $dbh->prepare($sql);
  $stmt->execute($path) or die "$DBI::errstr: $path";
}

# converts a string to seconds, possible variants
# 8.24 s
# 0:07:00
# returns number of seconds
sub duration_to_seconds($) {
  my ($s) = @_;
  my ($hour, $min, $sec, $msec) = (0, 0, 0, 0);

  if (($sec) = $s =~ /^([.\d]+) s$/) {
    # don't do anything just now
  } elsif (($hour, $min, $sec) = $s =~ /^(\d{1,2}):(\d{2}):(\d{2})$/) {
    # don't do anything just now
  } else {
    die "'$s': I don't understand this string";
  }
  print "Duration=", ($hour * 3600 + $min * 60 + $sec), " sec ($s)\n";
  return ($hour * 3600 + $min * 60 + $sec);
}

sub get_height(%) {
  my (%info) = @_;
  my $h = $info{'ImageHeight'};
  if (!defined($h)) {
    $h = $info{'ExifImageHeight'};
  }
  # print "height=$h\n";
  return $h;
}

sub get_width(%) {
  my (%info) = @_;
  my $w = $info{'ImageWidth'};
  if (!defined($w)) {
    $w = $info{'ExifImageWidth'};
  }
  # print "width=$w\n";
  return $w;
}

# get fileextension, can be jpg or jpeg, webm, m2ts, mts etc.
sub get_extension($) {
  my ($fname) = @_;
  my $ext = '';

  my $dot = rindex($fname, '.');
  if ($dot > -1) {
    $ext = lc substr($fname, $dot+1);
  }
  # print "ext=$ext\n";
  return $ext;
}

# return 1 to ignore the path or 0 to process the path
sub ignore_path($) {
  my ($path) = @_;
  if ($path =~ /\/Program Files\/|\/Program Files \(x86\)|ProgramData|\$Recycle\.Bin|\/AppData\/|\/mnt\/.\/Windows/i) {
    return 1;
  } else {
    return 0;
  }
}

# get the 'real' time of the picture or movie
# priority
# 1. EXIF:DateTimeOriginal
# 2. EXIF:CreateTime
# 3. File:ModifiedTime
sub control_time() {
}

sub process_file($$) {
  my ($dbh, $fname) = @_;
  my ($duration, $width, $height, $seconds, $json_exif, $digest, $info, $ext,
      $lat, $lon, $camera, $orig_time);

  my ($dev, $ino, $mode, $nlink, $uid, $gid, $rdev, $fsize, $atime, $mtime, $ctime, $blksize, $blocks) = stat $fname;
  if ($fsize < (1024)) {
    print "too small: $fname\n";
    return;
  }
  
  my $file_info = fetch_file_info($dbh, $fname);
  # insert if not found
  # update if found but changed

  if (defined($file_info)) {
    if ($fsize == $file_info->{'size'} || $mtime == $file_info->{'mtime'}) { # presumably not change since last scan
      reset_state($dbh, $fname);
      return;
    }
  }

  print "add: $fname\n";
  $info = ImageInfo($fname);

  $duration = %$info{'Duration'};
  $seconds = duration_to_seconds($duration) if $duration;

  $width = get_width(%$info);
  $height = get_height(%$info);
  $ext = get_extension($fname);
  $lat = %$info{'GPSLatitude'};
  $lon = %$info{'GPSLongitude'};
  $camera = %$info{'Model'};
  $orig_time = %$info{'DateTimeOriginal'};
  $json_exif = hash_to_json($info);
  $digest = digest_from_file($File::Find::name);
  insert_into_db($dbh, $File::Find::name, $_, $ext, $fsize, $mtime, $digest, $json_exif,
                 $width, $height, $seconds, $lat, $lon, $camera, $orig_time);
}

sub wanted {
  if (-f and /\.(jpeg|jpg|png|mts|m2ts|avi|webm|mp4|mks|mkv)$/i) {

    unless (ignore_path($File::Find::name)) {
      # print "$File::Find::name";
      process_file($main::dbh, $File::Find::name);
    }
  }
}

sub preprocess {
  # print "preprocess $File::Find::dir\n";
  # print @_;
  if (ignore_path($File::Find::dir)) {
    print "ignore directory $File::Find::dir\n";
    return [];
  } else {
    return @_;
  }
}

sub list_doubles($) {
  my ($dbh) = @_;
  my $stmt = $dbh->prepare("SELECT COUNT(*), digest FROM media GROUP BY digest HAVING COUNT(*) > 14");
  my $rv = $stmt->execute();
  my ($count, $digest, $path, $size, $date, @digests);
  while (($count, $digest) = $stmt->fetchrow()) {
    print "$count, $digest\n";
    push @digests, $digest;
  }
  print Dumper @digests;
  my $files = $dbh->prepare("SELECT size, path, datetime_original  FROM media WHERE digest = ?");
  foreach $digest (@digests) {
    $rv = $files->execute($digest);
    while (($size, $path, $date) = $files->fetchrow()) {
      print "$size: $path, $date\n";
    }
    print "---------------------------------\n";
  }
  exit;
}

sub delete_orphans($$) {
  my ($dbh, $dirs) = @_;
  my ($path, $dir, $fcount);
  $fcount = 0;
  foreach $dir (@{$dirs}) {
    my $stmt = $dbh->prepare("SELECT path FROM media WHERE path like '$dir%'");
    print "check under $dir\n" if $verbose;
    $stmt->execute();
    while (($path) = $stmt->fetchrow()) {
      # print "check $path\n";
      printf "%i\r", $fcount++ if $verbose;
      unless (-e $path) {
        print "$path not found\n";
        $dbh->do("DELETE FROM media WHERE path = '$path'");
        $DBI::err && die $DBI::errstr;
      }
    }
  }
}


# main starts here
#

my %opt = ();
my @dirs = ();
my $database = my_dir() . '/media.db';

print "database=$database\n";

GetOptions(\%opt,
           "verbose!" => \$verbose,
           "database=s" => \$database,
           "orphans",
           "doubles",
           "update",
           "dirs=s{1,}" => \@dirs
           );
           

# if there is no explicit directory parameter
# we'll use the remainder of the command line as directories
if (scalar @dirs == 0) {
  @dirs = @ARGV;
}

$main::dbh = connect_database($database);

if ($opt{'doubles'}) {
  list_doubles($main::dbh);
}

if ($opt{'update'}) {
  find({wanted => \&wanted, follow => 0, preprocess => \&preprocess}, @dirs);
}

if ($opt{'orphans'}) {
  print "delete orphans\n";
  delete_orphans($main::dbh, \@dirs);
}

$main::dbh->disconnect();

__DATA__
select path, (select j.value from json_each(t.exif) AS j WHERE j.key = 'CreateDate') AS data from media as t where data is null;
